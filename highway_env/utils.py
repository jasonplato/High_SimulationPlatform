from __future__ import division, print_function

import importlib

import numpy as np

DIFFICULTY_LEVELS = {
    "EASY": {
        "lanes_count": 2,
        "initial_spacing": 2,
        "vehicles_count": 5,
        "duration": 20,
        "other_vehicles_type": "highway_env.vehicle.behavior.IDMVehicle"
    },
    "MEDIUM": {
        "lanes_count": 3,
        "initial_spacing": 2,
        "vehicles_count": 10,
        "duration": 30,
        "other_vehicles_type": "highway_env.vehicle.behavior.IDMVehicle"
    },
    "HARD": {
        "lanes_count": 8,
        "initial_spacing": 3,
        "vehicles_count": 50,
        "duration": 40,
        "other_vehicles_type": "highway_env.vehicle.behavior.IDMVehicle"
    },
    "ORIGIN":{
        "lanes_count": 4,
        "initial_spacing": 3,
        "vehicles_count": 15,
        "duration": 40,
        "other_vehicles_type": "highway_env.vehicle.behavior.IDMVehicle"
    },
}
EPSILON = 0.01


def constrain(x, a, b):
    return np.minimum(np.maximum(x, a), b)


def not_zero(x):
    if abs(x) > EPSILON:
        return x
    elif x > 0:
        return EPSILON
    else:
        return -EPSILON


def wrap_to_pi(x):
    return ((x+np.pi) % (2*np.pi)) - np.pi


def point_in_rectangle(point, rect_min, rect_max):
    """
        Check if a point is inside a rectangle
    :param point:
    :param rect_min:
    :param rect_max:
    :return:
    """
    return rect_min[0] <= point[0] <= rect_max[0] and rect_min[1] <= point[1] <= rect_max[1]


def point_in_ellipse(point, center, angle, length, width):
    """
        Check if a point is inside an ellipse
    :param point: a point
    :param center: ellipse center
    :param angle: ellipse main axis angle
    :param length: ellipse big axis
    :param width: ellipse small axis
    """
    c, s = np.cos(angle), np.sin(angle)
    r = np.matrix([[c, -s], [s, c]])
    ru = r.dot(point - center)
    return np.sum(np.square(ru / np.array([length, width]))) < 1


def do_every(duration, timer):
    return duration < timer


def remap(v, x, y):
    return y[0] + (v-x[0])*(y[1]-y[0])/(x[1]-x[0])


def class_from_path(path):
    module_name, class_name = path.rsplit(".", 1)
    class_object = getattr(importlib.import_module(module_name), class_name)
    return class_object
